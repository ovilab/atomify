// File Name: marchingcubes.cpp
// Last Modified: 2014-04-13
// Author: Anders Hafreager (based on source code provided
// by Raghavendra Chandrashekara and Cory Bloyd: http://paulbourke.net/geometry/polygonise/marchingsource.cpp)
// Email: anderhaf@fys.uio.no
//
// Description: This is the implementation file for the MarchingCubes class.

#include "marchingcubesgenerator.h"
#include <cmath>
#include <QVector3D>
#include <QHash>
#include <QDebug>
#include <iostream>
#include <algorithm>
#include <QElapsedTimer>
#include <QColor>

// For any edge, if one vertex is inside of the surface and the other is outside of the surface
// then the edge intersects the surface
// For each of the 8 vertices of the cube can be two possible states : either inside or outside of the surface
// For any cube the are 2^8=256 possible sets of vertex states
// This table lists the edges intersected by the surface for all 256 possible vertex states
// There are 12 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1
const unsigned int MarchingCubesGenerator::m_edgeTable[256] = {
    0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
};

//  For each of the possible vertex states listed in aiCubeEdgeFlags there is a specific triangulation
//  of the edge intersection points.  a2iTriangleConnectionTable lists all of them in the form of
//  0-5 edge triples with the list terminated by the invalid value -1.
//  For example: a2iTriangleConnectionTable[3] list the 2 triangles formed when corner[0]
//  and corner[1] are inside of the surface, but the rest of the cube is not.
//
//  I found this table in an example program someone wrote long ago.  It was probably generated by hand
const int MarchingCubesGenerator::m_triangleTable[256][16] = {
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
    {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
    {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
    {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
    {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
    {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
    {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
    {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
    {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
    {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
    {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
    {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
    {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
    {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
    {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
    {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
    {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
    {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
    {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
    {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
    {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
    {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
    {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
    {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
    {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
    {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
    {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
    {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
    {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
    {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
    {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
    {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
    {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
    {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
    {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
    {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
    {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
    {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
    {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
    {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
    {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
    {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
    {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
    {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
    {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
    {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
    {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
    {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
    {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
    {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
    {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
    {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
    {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
    {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
    {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
    {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
    {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
    {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
    {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
    {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
    {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
    {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
    {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
    {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
    {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
    {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
    {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
    {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
    {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
    {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
    {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
    {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
    {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
    {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
    {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
    {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
    {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
    {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
    {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
    {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
    {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
    {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
    {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
    {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
    {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
    {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
    {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
    {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
    {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
    {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
    {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
    {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
    {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
    {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
    {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
    {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
    {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
    {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
    {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
    {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
    {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
    {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
    {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
    {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
    {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
    {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
    {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
    {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
    {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
    {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
    {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
    {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
    {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
    {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
    {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
    {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
    {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
    {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
    {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
    {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
    {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
    {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
    {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
    {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
    {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
    {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
    {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
    {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
    {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
    {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
    {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
    {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
    {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
    {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
    {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
    {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
    {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
    {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
    {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
    {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
    {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
    {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
    {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
    {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
    {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
    {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
    {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
    {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
    {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
    {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
    {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
    {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
    {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
    {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
    {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
    {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
    {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
    {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
    {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
    {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
    {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
    {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
    {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
    {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
    {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
    {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
    {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
    {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
    {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
    {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
    {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
    {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
    {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
    {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
    {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
    {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
    {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
    {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
    {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
    {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

Cube MarchingCubesGenerator::createCube() {
    // See http://paulbourke.net/geometry/polygonise/ for figure
    Cube cube;

    // Create edges
    cube.edges.edge0.point1 = &cube.vertices.v_000; // Vertex 0
    cube.edges.edge0.point2 = &cube.vertices.v_010; // Vertex 1

    cube.edges.edge1.point1 = &cube.vertices.v_010; // Vertex 0
    cube.edges.edge1.point2 = &cube.vertices.v_110; // Vertex 2

    cube.edges.edge2.point1 = &cube.vertices.v_110; // Vertex 2
    cube.edges.edge2.point2 = &cube.vertices.v_100; // Vertex 3

    cube.edges.edge3.point1 = &cube.vertices.v_100; // Vertex 3
    cube.edges.edge3.point2 = &cube.vertices.v_000; // Vertex 0


    cube.edges.edge4.point1 = &cube.vertices.v_001; // Vertex 4
    cube.edges.edge4.point2 = &cube.vertices.v_011; // Vertex 5

    cube.edges.edge5.point1 = &cube.vertices.v_011; // Vertex 5
    cube.edges.edge5.point2 = &cube.vertices.v_111; // Vertex 6

    cube.edges.edge6.point1 = &cube.vertices.v_111; // Vertex 6
    cube.edges.edge6.point2 = &cube.vertices.v_101; // Vertex 7

    cube.edges.edge7.point1 = &cube.vertices.v_101; // Vertex 7
    cube.edges.edge7.point2 = &cube.vertices.v_001; // Vertex 4


    cube.edges.edge8.point1 = &cube.vertices.v_000; // Vertex 0
    cube.edges.edge8.point2 = &cube.vertices.v_001; // Vertex 4

    cube.edges.edge9.point1 = &cube.vertices.v_010; // Vertex 1
    cube.edges.edge9.point2 = &cube.vertices.v_011; // Vertex 5

    cube.edges.edge10.point1 = &cube.vertices.v_110; // Vertex 2
    cube.edges.edge10.point2 = &cube.vertices.v_111; // Vertex 6

    cube.edges.edge11.point1 = &cube.vertices.v_100; // Vertex 3
    cube.edges.edge11.point2 = &cube.vertices.v_101; // Vertex 7

    return cube;
}


function<float (const QVector3D point)> MarchingCubesGenerator::scalarFieldEvaluator() const
{
    return m_scalarFieldEvaluator;
}

void MarchingCubesGenerator::setScalarFieldEvaluator(const function<float (const QVector3D point)> &scalarFieldEvaluator)
{
    std::cout << "Setting scalar field evaluator" << std::endl;
    m_scalarFieldEvaluator = scalarFieldEvaluator;
}

float MarchingCubesGenerator::threshold() const
{
    return m_threshold;
}

void MarchingCubesGenerator::setThreshold(float threshold)
{
    m_threshold = threshold;
}

void MarchingCubesGenerator::setColorEvaluator(const function<QVector3D (const QVector3D point)> &colorEvaluator)
{
    m_colorEvaluator = colorEvaluator;
}

void MarchingCubesGenerator::setColor(QVector3D color)
{
    m_color = color;
}

void MarchingCubesGenerator::setColor(const QColor &color)
{
    m_color = QVector3D(color.redF(), color.greenF(), color.blueF());
}

void MarchingCubesGenerator::updateCube(Cube &cube, const QVector3D &minValues, const QVector3D &vertexIndices, const QVector3D &delta) {
    cube.vertices.v_000.coordinates[0] = double(minValues[0]) + vertexIndices[0]*delta[0];
    cube.vertices.v_000.coordinates[1] = double(minValues[1]) + vertexIndices[1]*delta[1];
    cube.vertices.v_000.coordinates[2] = double(minValues[2]) + vertexIndices[2]*delta[2];

    cube.vertices.v_001.coordinates[0] = double(minValues[0]) + vertexIndices[0]*delta[0];
    cube.vertices.v_001.coordinates[1] = double(minValues[1]) + vertexIndices[1]*delta[1];
    cube.vertices.v_001.coordinates[2] = double(minValues[2]) + (vertexIndices[2]+1.0)*delta[2];

    cube.vertices.v_011.coordinates[0] = double(minValues[0]) + vertexIndices[0]*delta[0];
    cube.vertices.v_011.coordinates[1] = double(minValues[1]) + (vertexIndices[1]+1.0)*delta[1];
    cube.vertices.v_011.coordinates[2] = double(minValues[2]) + (vertexIndices[2]+1.0)*delta[2];

    cube.vertices.v_010.coordinates[0] = double(minValues[0]) + vertexIndices[0]*delta[0];
    cube.vertices.v_010.coordinates[1] = double(minValues[1]) + (vertexIndices[1]+1.0)*delta[1];
    cube.vertices.v_010.coordinates[2] = double(minValues[2]) + vertexIndices[2]*delta[2];

    cube.vertices.v_110.coordinates[0] = double(minValues[0]) + (vertexIndices[0]+1.0)*delta[0];
    cube.vertices.v_110.coordinates[1] = double(minValues[1]) + (vertexIndices[1]+1.0)*delta[1];
    cube.vertices.v_110.coordinates[2] = double(minValues[2]) + vertexIndices[2]*delta[2];

    cube.vertices.v_111.coordinates[0] = double(minValues[0]) + (vertexIndices[0]+1.0)*delta[0];
    cube.vertices.v_111.coordinates[1] = double(minValues[1]) + (vertexIndices[1]+1.0)*delta[1];
    cube.vertices.v_111.coordinates[2] = double(minValues[2]) + (vertexIndices[2]+1.0)*delta[2];

    cube.vertices.v_101.coordinates[0] = double(minValues[0]) + (vertexIndices[0]+1.0)*delta[0];
    cube.vertices.v_101.coordinates[1] = double(minValues[1]) + vertexIndices[1]*delta[1];
    cube.vertices.v_101.coordinates[2] = double(minValues[2]) + (vertexIndices[2]+1.0)*delta[2];

    cube.vertices.v_100.coordinates[0] = double(minValues[0]) + (vertexIndices[0]+1.0)*delta[0];
    cube.vertices.v_100.coordinates[1] = double(minValues[1]) + vertexIndices[1]*delta[1];
    cube.vertices.v_100.coordinates[2] = double(minValues[2]) + vertexIndices[2]*delta[2];

    cube.vertices.v_000.value = m_scalarFieldEvaluator(cube.vertices.v_000.coordinates);
    cube.vertices.v_001.value = m_scalarFieldEvaluator(cube.vertices.v_001.coordinates);
    cube.vertices.v_011.value = m_scalarFieldEvaluator(cube.vertices.v_011.coordinates);
    cube.vertices.v_010.value = m_scalarFieldEvaluator(cube.vertices.v_010.coordinates);
    cube.vertices.v_110.value = m_scalarFieldEvaluator(cube.vertices.v_110.coordinates);
    cube.vertices.v_111.value = m_scalarFieldEvaluator(cube.vertices.v_111.coordinates);
    cube.vertices.v_101.value = m_scalarFieldEvaluator(cube.vertices.v_101.coordinates);
    cube.vertices.v_100.value = m_scalarFieldEvaluator(cube.vertices.v_100.coordinates);
}

MarchingCubesGenerator::MarchingCubesGenerator()
{
    m_scalarFieldEvaluator = [](const QVector3D point) {
        std::cout << "Scalar field evaluator not set in MarchingCubesGenerator. Aborting!" << std::endl;
        return 0;
    };
}

MarchingCubesGenerator::~MarchingCubesGenerator()
{
    deleteSurface();
}

void MarchingCubesGenerator::generateSurface(QVector3D minValues, QVector3D maxValues, QVector3D numberOfVoxels, float threshold)
{
    QElapsedTimer elapsed;
    elapsed.start();

    if (m_validSurface) deleteSurface();
    float dx = (maxValues[0] - minValues[0]) / numberOfVoxels[0];
    float dy = (maxValues[1] - minValues[1]) / numberOfVoxels[1];
    float dz = (maxValues[2] - minValues[2]) / numberOfVoxels[2];
    QVector3D delta(dx, dy, dz);
    m_threshold = threshold;

    m_numberOfVoxels[0] = numberOfVoxels[0];
    m_numberOfVoxels[1] = numberOfVoxels[1];
    m_numberOfVoxels[2] = numberOfVoxels[2];

    // Generate isosurface.
    Cube cube = createCube();

    CubeVertices &cubeVertices = cube.vertices;
    CubeEdges &cubeEdges = cube.edges;

    for (unsigned int i = 0; i < m_numberOfVoxels[0]; i++) {
        for (unsigned int j = 0; j < m_numberOfVoxels[1]; j++) {
            for (unsigned int k = 0; k < m_numberOfVoxels[2]; k++) {
                QVector3D indices(i,j,k);
                updateCube(cube, minValues, indices, delta);

                // Calculate table lookup index from those
                // vertices which are below the isolevel.
                unsigned int tableIndex = 0;

                if (cubeVertices.v_000.value < m_threshold) tableIndex |= 1;
                if (cubeVertices.v_010.value < m_threshold) tableIndex |= 2;
                if (cubeVertices.v_110.value < m_threshold) tableIndex |= 4;
                if (cubeVertices.v_100.value < m_threshold) tableIndex |= 8;
                if (cubeVertices.v_001.value < m_threshold) tableIndex |= 16;
                if (cubeVertices.v_011.value < m_threshold) tableIndex |= 32;
                if (cubeVertices.v_111.value < m_threshold) tableIndex |= 64;
                if (cubeVertices.v_101.value < m_threshold) tableIndex |= 128;

                // Now create a triangulation of the isosurface in this cell.
                if (m_edgeTable[tableIndex] != 0) {
                    if (m_edgeTable[tableIndex] & 8) {
                        QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge3);
                        unsigned int id = getEdgeId(i, j, k, 3);
                        m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                    }

                    if (m_edgeTable[tableIndex] & 1) {
                        QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge0);
                        unsigned int id = getEdgeId(i, j, k, 0);
                        m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                    }

                    if (m_edgeTable[tableIndex] & 256) {
                        QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge8);
                        unsigned int id = getEdgeId(i, j, k, 8);
                        m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                    }

                    //if (i == m_numberOfVoxels[0] - 1) {
                        if (m_edgeTable[tableIndex] & 4) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge2);
                            unsigned int id = getEdgeId(i, j, k, 2);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                    //}
                   // if (i == m_numberOfVoxels[0] - 1) {
                        if (m_edgeTable[tableIndex] & 2048) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge11);
                            unsigned int id = getEdgeId(i, j, k, 11);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                    //}

                    //if (j == m_numberOfVoxels[1] - 1) {
                        if (m_edgeTable[tableIndex] & 2) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge1);
                            unsigned int id = getEdgeId(i, j, k, 1);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                        if (m_edgeTable[tableIndex] & 512) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge9);
                            unsigned int id = getEdgeId(i, j, k, 9);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                    //}

                    //if (k == m_numberOfVoxels[2] - 1) {
                        if (m_edgeTable[tableIndex] & 16) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge4);
                            unsigned int id = getEdgeId(i, j, k, 4);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                        if (m_edgeTable[tableIndex] & 128) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge7);
                            unsigned int id = getEdgeId(i, j, k, 7);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                    //}

                    //if ((i==m_numberOfVoxels[0] - 1) && (j==m_numberOfVoxels[1] - 1)) {
                        if (m_edgeTable[tableIndex] & 1024) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge10);
                            unsigned int id = getEdgeId(i, j, k, 10);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                    //}

                    //if ((i==m_numberOfVoxels[0] - 1) && (k==m_numberOfVoxels[2] - 1)) {
                        if (m_edgeTable[tableIndex] & 64) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge6);
                            unsigned int id = getEdgeId(i, j, k, 6);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                   // }

                    // if ((j==m_numberOfVoxels[1] - 1) && (k==m_numberOfVoxels[2] - 1)) {
                        if (m_edgeTable[tableIndex] & 32) {
                            QVector3D intersectionPoint = calculateIntersection(cubeEdges.edge5);
                            unsigned int id = getEdgeId(i, j, k, 5);
                            m_edgeMap.insert(VertexMap::value_type(id, intersectionPoint));
                        }
                    // }

                    for (unsigned int l = 0; m_triangleTable[tableIndex][l] != -1; l += 3) {
                        unsigned int vertex0Id = getEdgeId(i, j, k, m_triangleTable[tableIndex][l]);
                        unsigned int vertex1Id = getEdgeId(i, j, k, m_triangleTable[tableIndex][l+1]);
                        unsigned int vertex2Id = getEdgeId(i, j, k, m_triangleTable[tableIndex][l+2]);
                        m_trianglesFront.push_back(Triangle(vertex0Id, vertex1Id, vertex2Id));
                    }
                }
            }
        }
    }

    // Add all these triangles sequentially in memory and note the mapping between edgeID and
    // index in the sequential index
    m_data.resize(m_edgeMap.size());
    std::map<unsigned int, unsigned int> vertexMap;

    unsigned int counter = 0;
    for(auto it=m_edgeMap.begin(); it!=m_edgeMap.end(); it++) {
        QVector3D &vertex = it->second;
        unsigned int index = it->first;
        // Map this vertex in the map to the index of the sequential vector
        vertexMap[index] = counter;
        m_data[counter].vertex = vertex;
        if(!m_hasColorEvaluator) m_data[counter].color = m_color;
        else m_data[counter].color = m_colorEvaluator(vertex);
        counter++;
    }

    // Update triangle list with the new indices
    m_trianglesBack.resize(m_trianglesFront.size());
    m_lines.resize(m_trianglesFront.size());
    for(unsigned int i=0; i<m_trianglesFront.size(); i++) {
        Triangle &triangleFront = m_trianglesFront[i];
        Triangle &triangleBack = m_trianglesBack[i];
        TriangleLines &triangleLines = m_lines[i];

        // Switch the indices from edgeID ordering to sequential ordering
        triangleFront.vertexIndices[0] = vertexMap[triangleFront.vertexIndices[0]];
        triangleFront.vertexIndices[1] = vertexMap[triangleFront.vertexIndices[1]];
        triangleFront.vertexIndices[2] = vertexMap[triangleFront.vertexIndices[2]];

        // The back triangles are just rendered with opposite order
        triangleBack.vertexIndices[0] = triangleFront.vertexIndices[2];
        triangleBack.vertexIndices[1] = triangleFront.vertexIndices[1];
        triangleBack.vertexIndices[2] = triangleFront.vertexIndices[0];

        // A triangle consists of 3 lines - each line represented by 2 points
        triangleLines.vertexIndices[0] = triangleFront.vertexIndices[0];
        triangleLines.vertexIndices[1] = triangleFront.vertexIndices[1];
        triangleLines.vertexIndices[2] = triangleFront.vertexIndices[1];
        triangleLines.vertexIndices[3] = triangleFront.vertexIndices[2];
        triangleLines.vertexIndices[4] = triangleFront.vertexIndices[2];
        triangleLines.vertexIndices[5] = triangleFront.vertexIndices[0];
    }

    qDebug() << "Marching cubes created with " << m_data.size() << " vertices, " << 2*m_trianglesFront.size() << " triangles and " << 6*m_lines.size() << " lines in " << elapsed.elapsed() << " ms.";

    elapsed.restart();
    calculateNormals();

    m_edgeMap.clear();
    vertexMap.clear();
    m_validSurface = true;
}

void MarchingCubesGenerator::deleteSurface()
{
    m_data.clear();
    m_trianglesFront.clear();
    m_trianglesBack.clear();
    m_threshold = 0;
    m_validSurface = false;
}

unsigned int MarchingCubesGenerator::getEdgeId(unsigned int i, unsigned int j, unsigned int k, unsigned int nEdgeNo)
{
    switch (nEdgeNo) {
    case 0:
        return getVertexID(i, j, k) + 1;
    case 1:
        return getVertexID(i, j + 1, k);
    case 2:
        return getVertexID(i + 1, j, k) + 1;
    case 3:
        return getVertexID(i, j, k);
    case 4:
        return getVertexID(i, j, k + 1) + 1;
    case 5:
        return getVertexID(i, j + 1, k + 1);
    case 6:
        return getVertexID(i + 1, j, k + 1) + 1;
    case 7:
        return getVertexID(i, j, k + 1);
    case 8:
        return getVertexID(i, j, k) + 2;
    case 9:
        return getVertexID(i, j + 1, k) + 2;
    case 10:
        return getVertexID(i + 1, j + 1, k) + 2;
    case 11:
        return getVertexID(i + 1, j, k) + 2;
    default:
        qDebug() << "Invalid edge ID, something is clearly wrong.";
        exit(1);
    }
}

unsigned int MarchingCubesGenerator::getVertexID(unsigned int i, unsigned int j, unsigned int k)
{
    return 3*(k*(m_numberOfVoxels[1]+1)*(m_numberOfVoxels[0]+1) + j*(m_numberOfVoxels[0]+1) + i);
}

QVector3D MarchingCubesGenerator::calculateIntersection(Edge &edge)
{
    float linearDistance = (m_threshold - edge.point1->value) / (edge.point2->value - edge.point1->value);
    QVector3D intersectionPoint;

    intersectionPoint[0] = edge.point1->x() + linearDistance*(edge.point2->x() - edge.point1->x());
    intersectionPoint[1] = edge.point1->y() + linearDistance*(edge.point2->y() - edge.point1->y());
    intersectionPoint[2] = edge.point1->z() + linearDistance*(edge.point2->z() - edge.point1->z());

    return intersectionPoint;
}

void MarchingCubesGenerator::calculateNormal(MarchingCubesVBOData &data) {
    // Numerical differentiation with the two point formula:
    // f' â‰ˆ ( f(x+h) - f(x-h) ) / 2h
    static const float h = 0.01;
    static const float oneOverTwoH = 1.0 / (2*h);

    float fPlusX = m_scalarFieldEvaluator(QVector3D(data.vertex.x() + h, data.vertex.y(), data.vertex.z()));
    float fMinusX = m_scalarFieldEvaluator(QVector3D(data.vertex.x() - h, data.vertex.y(), data.vertex.z()));

    float fPlusY = m_scalarFieldEvaluator(QVector3D(data.vertex.x(), data.vertex.y() + h, data.vertex.z()));
    float fMinusY = m_scalarFieldEvaluator(QVector3D(data.vertex.x(), data.vertex.y() - h, data.vertex.z()));

    float fPlusZ = m_scalarFieldEvaluator(QVector3D(data.vertex.x(), data.vertex.y(), data.vertex.z() + h));
    float fMinusZ = m_scalarFieldEvaluator(QVector3D(data.vertex.x(), data.vertex.y(), data.vertex.z() - h));

    data.normal[0] = (fPlusX - fMinusX) * oneOverTwoH;
    data.normal[1] = (fPlusY - fMinusY) * oneOverTwoH;
    data.normal[2] = (fPlusZ - fMinusZ) * oneOverTwoH;
    data.normal.normalize();
}

void MarchingCubesGenerator::calculateNormals()
{
    if(m_hasContinuousField) {
        for (MarchingCubesVBOData &data : m_data) {
            calculateNormal(data);
        }
    } else {
        for(Triangle &triangle : m_trianglesFront) {
            MarchingCubesVBOData &v0 = m_data[triangle.vertexIndices[0]];
            MarchingCubesVBOData &v1 = m_data[triangle.vertexIndices[1]];
            MarchingCubesVBOData &v2 = m_data[triangle.vertexIndices[2]];
            QVector3D p1 = v1.vertex - v0.vertex;
            QVector3D p2 = v2.vertex - v0.vertex;
            QVector3D crossProduct = QVector3D::crossProduct(p1, p2);
            QVector3D normal = crossProduct;

            v0.normal += normal;
            v1.normal += normal;
            v2.normal += normal;
        }

        for(MarchingCubesVBOData &data : m_data) {
            data.normal.normalize();
        }
    }
}
